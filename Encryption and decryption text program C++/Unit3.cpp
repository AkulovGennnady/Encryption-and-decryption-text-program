//---------------------------------------------------------------------------


#pragma hdrstop
#include "Unit3.h"
#include <cstring.h>
#include <string.h>      // AnsiString
#include <SysUtils.hpp>  // AnsiString

#include <math.h>       /* ceil */
#include <time.h>


//---------------------------------------------------------------------------

#pragma package(smart_init)

//0.del_space - удаление пробелов
string del_space(string s){
  char a;
	while((a=s.find(' '))!=string::npos )
		s.erase(a,1);
  return s;
 }

//1.Цезарь
//одинаковый алгоритм для 2 операций, разница в знаке ключа!
//----------------------------------------------------------------------
string Caesar_enc_decr(string s1, int b){
     s1=del_space(s1);//удаление пробелов

	string s2;//зашифрованное сообщение
	for (int i=0;(unsigned)i<s1.length();i++){
                //англ алфавит
		if (((int)(s1[i]) >= 97) && ((int)(s1[i]) <= 122)){
			if ((int)(s1[i]) + b > 122)
				s2+=(char)((int)(s1[i])+b-26);
			else if ((int)(s1[i]) + b < 97)
				s2+=(char)((int)(s1[i])+b+26);
			else
				s2+=(char)((int)(s1[i])+b);
		}
                //кириллица
		if (((int)(s1[i]+33)>=1)&&((int)(s1[i]+33)<=32)){
			if ((int)(s1[i]+33)+b>32)
				s2+=(char)((int)(s1[i])+b-32);
			else if ((int)(s1[i]+33)+b<1)
				s2+=(char)((int)(s1[i])+b+32);
			else
				s2+=(char)((int)(s1[i])+b);
		}
         //при дешифровке
        //для буквы ё, код которой -(72)
        //заменим ее на ж, на ее месте она должна быть по алфавиту
        if ( s1[i]=='ё')
          s2+=(char)((int)('ж')+b);
	}

       return s2;
}

//2.Перестановочный
//----------------------------------------------------------------------
 string Perest_enc(string s1, string p1){
    s1=del_space(s1);//удаление пробелов
     int n=5; //5 строк
      string s2;//зашифрованное сообщение

   int i,j;
   //преобразование в массив чисел строки с ключем
     int *p = new int [n];
       for (i=0;i<n;i++)
        p[i]=StrToInt(p1[i])-1;

    //необходимое количество строк
    float t = (float) s1.length()/n;
    //даже если 1 символ остался - созд. еще одну строку
     int m = ceil(t);//строки

   char **A = new char* [m]; //  m строк в матрице
    for (int count = 0; count < m; count++)
        A[count] = new char [n]; // и пять столбцов

    srand(time(NULL));  // инициализировать генератор
     int k=0;//подсчет количества символов строки

      //преобразование в двумерный массив
      for (i=0; i<m; i++){
       for (j=0; j<n; j++){
        if ((unsigned)k>=s1.length())
        //если привышает длину строки с сообщением, забиваем мусором
           *(*(A+i)+j)= (char) ( rand() % 25 + 97 ); //латиница от 97 до 122
              else //если не превышает длину сообщения
		*(*(A+i)+j)=s1[k];
		    k++;
			 }
		   }
      //запись в 1 строку с учетом перестановки столбцов по строке
      for (i=0; i<m; i++)
	  for (int r=0; r<n; r++){
	      j=p[r];
	        s2+=*(*(A+i)+j);
                  }
   return s2;
}
//----------------------------------------------------------------------
 string Perest_decr(string s1, string p1){
   s1=del_space(s1);//удаление пробелов

  int n=5; //5 строк
   string s3;//зашифрованное сообщение

    int i,j;
   //преобразование в массив чисел строки с ключем
     int *p = new int [n];
       for (i=0;i<n;i++)
         p[i]=StrToInt(p1[i])-1;

     //необходимое количество строк
     float t = (float) s1.length()/n;
     //даже если 1 символ остался - созд. еще одну строку
       int m = ceil(t);//строки

   char **A = new char* [m]; //  m строк в матрице
    for (int count = 0; count < m; count++)
        A[count] = new char [n]; // и пять столбцов

   int k=0;//контроль кол-ва итераций, чтобы не выйти за предел строки
      for (i=0; i<m; i++){
       for (j=0; j<n; j++){
         if ((unsigned)k>=s1.length()) break;
             *(*(A+i)+j)=s1[k];
	        k++;
                 }
		  }

  //расшифровка сообщения, с учетом перестановки столбцов, цикл по строкам
   for (i=0; i<m; i++)
     for (int r=0; r<n; r++){
      for ( k=0; k<n; k++)
	if (r==p[k])
	  j=k;//столбец равен индексу
            s3+=*(*(A+i)+j);
              }
 return s3;
}


//3.MagicSqr
//----------------------------------------------------------------------
string MagicSqr_enc(string s1, string p1){
  s1=del_space(s1);//удаление пробелов

  int n=4;//столбца
  string s2;//зашифрованное сообщение

  int i,j;
  //преобразование в массив чисел строки с ключем
   int *p = new int [n];
    for (i=0;i<n;i++)
      p[i]=StrToInt(p1[i])-1;

   //создание 2-мерного массива шифр. сообщ.
    float t = (float) s1.length()/n;
    //даже если 1 символ остался - созд. еще одну строку
     int m = ceil(t);//строки

   char **A = new char* [m]; //  m строк в матрице
    for (int count = 0; count < m; count++)
        A[count] = new char [n]; // и пять столбцов

    srand(time(NULL)); //инициализировать генератор
     int k=0;
     //контроль кол-ва итераций, чтобы не выйти за предел размера строки
      for (i=0; i<m; i++){
	 for (j=0; j<n; j++){
         //если привышает длину строки с сообщением, забиваем мусором
           if ((unsigned)k>=s1.length())
             *(*(A+i)+j)= (char)( rand() % 25 + 97 ); //латинский алф от 97 до 122
                else
		 *(*(A+i)+j)=s1[k];
		    k++;	
		       }
		         }
  //зашифровка сообщения, с учетом расстановки символов по квадрату
    for (i=0; i<m; i++)
      for (int r=0; r<n; r++){
        j=p[r];
	  s2+=*(*(A+i)+j);
		  }
  return s2;
}
 //----------------------------------------------------------------------
 string MagicSqr_decr(string s1, string p1){
  s1=del_space(s1);//удаление пробелов
  int n=4; //4 столбца
  string s3; //расшифрованное сообщение

   int i,j;
   //преобразование в массив чисел строки с ключем
    int *p = new int [n];
      for (i=0;i<n;i++)
       p[i]=StrToInt(p1[i])-1;

    //создание 2-мерного массива шифр. сообщ.
    float t = (float) s1.length()/n;
    //даже если 1 символ остался - созд. еще одну строку
      int m = ceil(t);//строки

   char **A = new char* [m]; //  m строк в матрице
    for (int count = 0; count < m; count++)
        A[count] = new char [n]; // и пять столбцов


   int k=0;//контроль кол-ва итераций, чтобы не выйти за предел строки
      for (i=0; i<m; i++){
         for (j=0; j<n; j++){
            if ((unsigned)k>=s1.length()) break;
                *(*(A+i)+j)=s1[k];
		    k++;
                     }
		      }
    //расшифровка сообщения, с учетом расстановки символов по квадрату
     for (i=0; i<m; i++)
       for (int r=0; r<n; r++){
	 for ( k=0; k<n; k++)
	   if (r==p[k])
	     j=k;//столбец равен индексу массива ключа
               s3+=*(*(A+i)+j);
		  }
 return s3;
}



//4. Полибия
//----------------------------------------------------------------------
string Polybius_enc(string s1, string key){
    s1=del_space(s1);//удаление пробелов
    string s2;
    //определяем алфавит по 1 символу, кириллица или латиница
    //англ алфавит
                            //c   l  o   u   d
     char dp[5][5] =    {{'a','b','c','d','e'},
		         {'f','g','h','i','k'},
			 {'l','m','n','o','p'},
			 {'q','r','s','t','u'},
			 {'v','w','x','y','z'}};


 for (int n=0; (unsigned)n<s1.length(); n++)
  for (int i=0; i<5; i++)
   for (int j=0; j<5; j++)//по ключу
    if (s1[n]==dp[i][j]){//если в строке оказывается символ из мас. dp
     s2.append(key,j,1);//добавление в сообщение найденного символа ключа по столбцу
     s2.append(key,i,1);//добавление в сообщение найденного символа ключа по строке
      			};
 return s2;
}
//----------------------------------------------------------------------
string Polybius_decr(string s2, string key){
       s2=del_space(s2);//удаление пробелов
        string s3;

    
   //англ алфавит
                            //c   l  o   u   d
     char dp[5][5] =    {{'a','b','c','d','e'},
		         {'f','g','h','i','k'},
			 {'l','m','n','o','p'},
			 {'q','r','s','t','u'},
			 {'v','w','x','y','z'}};


  for (int n=0; (unsigned)n<s2.length(); n+=2)
    s3+=dp[key.find(s2[n+1])][key.find(s2[n])];


 return s3;
}
//----------------------------------------------------------------------

//5.Gamma
//различие в шифровании и дешифровании в знаке
 //----------------------------------------------------------------------
string Gamma_enc_decr (string s1, string p, int sign){
   s1=del_space(s1);//удаление пробелов
   int i;
   string s2;//зашифрованное сообщение

   int k = 0;
	for (i=0; (unsigned)i<s1.length(); i++){
	   s2+= (s1[i]+sign*p[k]);
           //+при шифровании -при дешфифровании
		 if (k==4) k=-1;
		  k++;
	}
  return s2;
}
 //----------------------------------------------------------------------



